# academy-api

Этот репозиторий содержит API для академии. Академия Градосферы — это образовательная платформа, распространяемая через мини-приложение Telegram. Преподаватель может загружать структурированные учебные материалы и делиться ими со студентами, используя созданное мини-приложение в отдельном боте Telegram.

Структура учебных материалов:

- Каждый `mini-app` содержит `products` (например, курсы или вебинары по озеленению или благоустройству)
- `product` состоит из `lessons`, сгруппированных по `modules`
- `product` также может включать платные опции для разблокировки уроков (в codebase и DB они называются `product level`). Они также могут включать некоторые материалы в виде `bonus`
- `lesson` включает следующие категории: основной материал, список других материалов, домашнее задание.

Роли пользователей распределены между:

- `owner` - пользователь Telegram, создавший мини-приложение, с максимальным доступом к редактированию API.
- `student` - обычный пользователь, который может просматривать доступные материалы и отправлять домашние задания.
- `moderator` - в зависимости от выбранного вручную набора прав доступа может дублировать часть прав на запись, предоставленных владельцем.

В настоящее время для каждого мини-приложения разрешен только один владелец, и пользователь может создать только одно мини-приложение. Владельцам и модераторам всех мини-приложений следует использовать специальный Telegram-бот (далее именуемый администратором Telegram-бота).

## Использование API

Все описанные методы API используют Swagger API (спецификация OpenAPI версии 3), доступный через `GET {hostname}/v1/swagger/index.html`.

Последовательность действий преподавателя (владельца) для настройки нового мини-приложения:

1. Создайте новое мини-приложение (`POST {hostname}/v1/app`). В запросе владелец должен предоставить `init_data` от администратора Telegram-бота. При желании можно указать `bot_token` и `name`, чтобы ученики тоже могли присоединиться, или же эти параметры можно заполнить позже (с помощью `POST {hostname}/v1/app/edit/account`).
2. Войдите в кабинет преподавателя (`POST {hostname}/v1/auth/admin/signin`), используя `init_data` от администратора Telegram-бота, и получите `access_token`, используемый для доступа ко всем остальным методам и идентификации владельца с полными правами.
3. Используя `access_token`, владелец может получить список продуктов (`GET {hostname}/v1/app`). При запуске он будет включать только демо-версию продукта, демонстрирующую использование интерфейса.
4. Теперь, когда всё работает, владелец может продолжить использовать кабинет преподавателя: настраивать контент и систему оплаты за жетоны Благо, приглашать модераторов или студентов, оставлять отзывы о студентах и т.д.

Последовательность действий для модератора, чтобы получить доступ к мини-приложению:

1. Перед входом в систему модератор должен получить ссылку-приглашение от владельца. Приглашение содержит список прав, которые будут предоставлены модератору.
2. Используя отдельный метод входа в API (`POST {hostname}/v1/auth/mod/signin`), пользователь должен передать `invite_id` вместе с `init_data` от администратора Telegram-бота. Ответ будет содержать те же данные, что и для преподавателя/студентов, а также список активных прав.
3. При следующем входе модератора ему следует сначала использовать API-метод для получения списка мини-приложений, доступных для модерации (`POST {hostname}/v1/auth/mod/list`). Затем, используя тот же API-метод для входа модератора (`POST {hostname}/v1/auth/mod/signin`), указать `mini_app_id` вместо `invite_id`.

## Интеграция платежей

### Интеграция платежей TON или Благо в существующую кодовую базу

1. Преподаватель создает TON-кошелек и отправляет адрес на сервер.
2. Пользователь хочет оплатить доступ к курсу.
3. Генерирует идентификатор платежа, связывающий пользователя с продуктом.
4. Отправляет TON-адрес преподавателя и генерирует идентификатор платежа.
5. Фронтенд использует идентификатор платежа в качестве примечания к транзакции и отправляет необходимое количество жетонов Благо на адрес преподавателя.
6. Бэкенд постоянно отслеживает новые действительные переводы жетонов каждого преподавателя, добавившего адрес TON.
7. Если перевод жетона действителен, включается заметка о сохраненном в базе данных идентификаторе платежа и количестве жетонов, соответствующих требованиям, после чего статус платежа изменится, и платный контент будет разблокирован для пользователя.

Использование жетонов Благо может обеспечить настройку, аналогичную традиционным платежным сервисам, а также повысить безопасность, не храня конфиденциальные учетные данные на бэкенде.

### Проблемы работы с блокчейном TON

При интеграции блокчейна TON возникли некоторые проблемы.

Собственные API и SDK сложно использовать из-за следующих проблем:

- Наличие множества поставщиков узлов с разным, нечетким лимитом истории;
- Нестабильное поведение узлов даже для легких узлов;
- Отсутствие поддержки вебхуков;
- Сложности мониторинга блокчейна со сложной системой шардинга;
- Отсутствие видимости транзакций для адресов без баланса TON (даже при наличии других жетонов);
- Сложная структура транзакций при передаче жетонов и процессе проверки.

По указанным причинам сторонние сервисы могут быть хорошим вариантом. В этом проекте сервис TonAPI (https://docs.tonconsole.com/tonapi) используется в качестве резервного на случай удаления учётной записи с узла TON из-за отсутствия баланса TON.

Также TonAPI поддерживает такие функции, как подписка на получение новых транзакций по выбранным адресам и многое другое. Это улучшает интеграцию и упрощает разработку и поддержку.

## Технические подробности

Постоянные данные хранятся отдельно в Redis (для кэширования токенов обновления) и PostgreSQL (для хранения практически любых других данных). Проект также использует файловую систему Unix для хранения загруженных файлов.

Перед созданием новых мини-приложений необходимо создать основное мини-приложение для учителей, позволяющее им выполнять первоначальную авторизацию пользователей Telegram. Используйте `TELEGRAM_BOT_TOKEN` для настройки бота администратора Telegram.

`ENCRYPTION_KEY` используется для шифрования и дешифрования секретных данных, хранящихся в PostgreSQL. Сюда входят токен бота мини-приложения учителя и пароль WayForPay. Он должен иметь размер 16 или 24 символа, чтобы быть совместимым с функцией `aes.NewCipher` и соответствовать ограничениям базы данных. Этот код можно использовать для генерации нового ключа:

```go
package main

import (
	"crypto/rand"
	"encoding/hex"
	"io"
)

func main() {
	nonce := make([]byte, 24)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		panic(err)
	}
	println(hex.EncodeToString(nonce))
}
```

При внесении любых изменений в структуру загружаемых материалов (аватары, логотипы, видео, изображения, PDF-файлы и т. д.) убедитесь, что сервис **auth-removal** синхронизирован с другими частями проекта. Это связано с тем, что сервис **auth-removal** удаляет все загруженные файлы, которые не следуют строго заданному пути и не назначены существующим ресурсам в базе данных Postgres. Подробности см. в файле `internal/service/upload/upload.go` (например, метод `ClearDanglingUploads`).

Также при внесении изменений в модели убедитесь, что новая схема совместима с **triggers** (в отдельном файле в миграциях). Это связано с тем, что некоторые ошибки будут срабатывать только во время выполнения, что затруднит их последующее тестирование/отладку.

В настоящее время для загружаемых видеоматериалов используетс сервис Mux. Для активации этого сервиса загружайте видеофайлы по частям и отправляйте их со статусом `pending_move_to_mux`. После этого cron-задание выберет их и загрузит в Mux. Документацию по самому сервису и API можно найти по адресу https://www.mux.com/docs/guides/upload-files-directly. Материалы Mux будут включать `metadata`, используемые для генерации временных ссылок на воспроизведение видео (`playback_id`), и `asset_id`, используемый для удаления ресурсов при удалении материала пользователем.

## Настройка проекта

1. Клонируйте репозиторий:

```sh
git clone https://github.com/gradosphera/academy.git
cd academy/Backend
```

1. Создайте файл `.env`:

```sh
cp .env.example .env
```

3. Настройте базы данных postgres и redis, например, с помощью docker:

```sh
docker run -d --name some-redis -p 6379:6379 \
            redis:latest redis-server --requirepass your_strong_password
docker run -d --name some-postgres -p 5432:5432 -e POSTGRES_PASSWORD=mysecretpassword \
            postgres
```

4. Создайте файл конфигурации для основного бота TG, который будет отвечать на команду `/start`. Например, в `resources/bot.config.json` (`TELEGRAM_BOT_CONFIG`) создайте файл со следующим содержимым:

```json
{
  "response": {
    "command": "start",
    "message": "Добро пожаловать в Академию Градосферы...",
    "button_text": "Create mini-app",
    "button_link": "https://t.me/example_name_bot/example_name_mini_app"
  }
}
```

Также используйте `TELEGRAM_BOT_IMAGE` для указания изображения, которое будет использоваться в ответном сообщении.

1. Если вам нужно использовать пользовательское сжатие видеофайла с помощью `ffmpeg` (можно использовать с загруженными материалами со статусом `pending_compressing`), то исполняемый файл `ffmpeg` следует включить в исполняемый файл проекта. В настоящее время `ffmpeg` отключен. Вместо этого видео можно загрузить на отдельный сторонний сервис, например `Mux`.

Первоначальная проблема со сжатием заключалась в том, что некоторые видео не оптимизированы для просмотра в вебе. Поэтому возможность простого скачивания пользователем случайных файлов `.mp4` могла привести к нестабильной работе.

6. Конфигурации демонстрационного продукта следует добавить в `UPLOAD_DIRECTORY` в каталоге `demo`. Файлы, которые следует включить в этот каталог, можно найти в исходном коде `/internal/service/upload/demo.go`. Файл содержит жёстко заданные имена файлов и алгоритм их использования.

7. Заполните `.env`, используя: учетные данные БД, основной бот Telegram и т. д.

8. Соберите и запустите исполняемый файл:

```sh
go build ./cmd/app
./app
```

## Структура проекта

```
├── .env          # Переменные окружения
├── cmd/          # Каталог с исполняемыми файлами для сборки
├── internal/     # Внутренний код приложения
│ ├── api/        # Уровень API (обработчики HTTP)
│ ├── config/     # Загрузка конфигурации из переменных окружения
│ ├── cron/       # Фоновые задания cron для очистки неиспользуемых ресурсов
│ ├── database/   # Коннекторы к базе данных
│ ├── logger/     # Настройка для logger
│ ├── model/      # Модели данных
│ ├── service/    # Уровень сервисов (бизнес-логика)
│ ├── storage/    # Уровень репозитория (доступ к данным)
│ └── types/      # Пользовательские типы Go
├── migrations/   # Миграции для PortgreSQL
└── resources/    # Статические ресурсы и загруженные файлы
```

## Нужно сделать

### Задачи

1. Отправлять аналитику учителю через Telegram-бот в 13:00 по местному времени
2. Добавить покупку создателем курсов - тарифных планов мини-приложений

### Исправить

1. Обрабатывать одновременные загрузки чанков. Возможные крайние случаи:

- загрузка одного и того же файла (первый будет работать, но второй перезапишет материал повреждёнными данными)
- загрузка разных файлов (например, после отмены загрузки большого файла и начала загрузки маленького, что может привести к повреждению данных из старого большого файла в маленький)

2. Рассмотреть возможность учёта размера сгенерированных файлов Excel для мини-приложения Ограничение
3. Возможность реализации автоматического удаления ресурсов мультиплексора для ресурсов, не подключенных к каким-либо ресурсам в базе данных Postgres. Причины не добавлять эту функцию:

- Мультиплексор взимает плату только за время воспроизведения, а не за размер или количество материалов.
- Некоторые ресурсы может быть полезно сохранить, поэтому следует реализовать чёткое разделение сред (отдельные среды prod/stage в мультиплексоре и исключить их повторное использование вне проекта).
- Текущая реализация с использованием `mux_assets_to_delete` достаточна для большинства случаев использования.
